# Leetcode 1442 题解

当前对这道题目的认识和解法介绍:
以下是刷题步骤：
1. 搞清楚，题目是什么。
2. 验证和搞清楚接这个题目的思路是什么。
3. 用编程语言的数据结构来实现想法.
4. 了解实现的优缺点，

## 题目:

### 1442. 形成两个异或相等数组的三元组数目
给你一个整数数组 arr .
现需要从数组中取三个下标 i、j 和 k ，其中 (0 <= i < j <= k < arr.length) .
a 和 b 定义如下：
a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
注意：^ 表示 按位异或 操作。

请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。

提示：
1 <= arr.length <= 300
1 <= arr[i] <= 10^8

题目来源:
https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/

### 题目相关知识点:

#### 异或运算符
异或运算符 ^ 的特性,用到了下面这个特性:
```
(1^2^3) ^ (1^2^3) == 0
```
这是因为异或的意思是: 
1) 如果相同的数, 就会返回 0
2) 如果不同的数, 就会返回 每个位置都为 1 的最终数字.

#### 前缀和
前缀和是一种预处理的手段, 一维前缀和的含义如下:
```
arr =  {1, 2, 3,4,5,6}
sums = {0, 1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5, 1+2+3+4+5+6}
```
sums 里面第0项是0, 是故意设置了,因为表示0个前置项的和为0.
这样,假设我需要第k个项目和第i个项目的区间和(即: [i,k]), 就可以这么使用.
sums[k] - sums[i-1]
就能够快速的得到 i + (i+1) + ... + k 的和. 
这仅需要O(1),就是这种处理手段的优点. 
同时设置第0项为0,也是方便对于语义的统一. 比方说想一个不要这样的和.就只需要 sums[0],而不用特殊输入一个0. 人类语义sums[5]-sums[1],表示[1,5]比sums[4]-sums[0]会容易理解一些. 所以如此设置.
不同的设置方法,本质上一样的,选择一个自己接受的就好.

上面所说是对于运算符号加号"+"来说进行运用, 很容易验证对于异或运算符"^"也是适用的.比方说下面的数组可以得到
```
arr = {1, 2, 3 , 4, 5, 6, 7}
xor_sums = {0, 1, 3, 0, 4, 1, 7 , 0}
```
上面的数字都是利用 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 进行计算出来的.
同样,区间和也能够适用, 因为上面说过 (1 ^ 2 ^ 3) ^ (1 ^ 2 ^ 3) = 0
并且 0 和任何数异或都为任何数
所以有,如果只想要 第4项目和第6项的异或和(即使[4,6]),可以使用 xor_sums[6] ^ xor_sums[4-1]. 
因为这表示 (1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6) ^ (1 ^ 2 ^ 3) = (4 ^ 5 ^ 6)

前缀和含义参考:
https://www.jianshu.com/p/d0dabea38302

## 解题思想:

### 思想一: 异或性质 + 前缀和
本章节尝试通过讲解怎么产生这些思路,来让读者了解, 每个工具有什么作用,已保证各位在日常应用中遇到相同的需求,才会采取相应手段来解决需求.

#### 思路预览
1). 从题目中得出, a == b 必然能够 a ^ b == 0, 所以,我们必须要寻找的是 xor_sum(i,k) == 0 的特征异或和.
2). 因为以上的特征要求我们知道[i,k]前缀和, 普通的求前缀和会使算法复杂度增加, 所以我们预处理[0, N] 的前缀和, 为了能够在O(1)的情况下得到[i,k]的前缀和.
3). 通过两个for循环,寻找所有在 [0, N]范围内[i,k]的组合.

#### 思路讲解
定义题目中的异或和为符号 xorsum(i, j), 表示范围 [i, j]中的数字的异或和.
即: xorsum(i, j) = arr[i]∧arr[i+1]∧⋯∧arr[j].
那么题目中所求的有a和b,可以这么表示
```
a = arr[i]∧arr[i+1]∧⋯∧arr[j-1] = xorsum(i, j-1)
b = arr[j]∧arr[j+1]∧⋯∧arr[k] = xorsum(i, j-1)
```
所求的是 a 与 b 相等,那么根据异或的知识, a ^ b == 0.
也就是说, 上面题目的所要我们求的, 是在数组中寻找一个三元组(i, j, k), 能够使得 xorsum(i,k)= a ∧ b = 0.
但是这里还有一个疑问, 我们可以知道 xorsum(i,k) == 0, 但是在 (i, k] 范围内(注意, 上面要求 j 是 在范围 (i,k] 这个范围里面), 会有多少个 j?
由于我对异或的性质掌握不够,我直接实践出来.
通过下面的例子看下:
```
1^2^3^4^5^6^7 = 0
1 = 1, 2^3^4^5^6^7 = 1 (j从2开始)
1 ^ 2 = 3, 3^4^5^6^7 = 3 (j从0开始)
```
通过上面的例子可以知道, 假如 j 可以是(i,k]范围内的任何一个,所以数目一共是k-i个.
另外,通过上面的实践现象, 可以知道一个异或的属性, 假如有一个是[i,k], 那么假设有 j 属于 (i,k], 那么会有以下的特性:
i^...^j-1 == 某数 == j ^ j+1 ^ ... ^ k

所以,假设有了某个范围的 [i,k] 的前缀和, 那么假设 xor_sum(i, k) 为 0.就可以知道, 在这个范围内必然会存在 j, 使得 i^...^j-1 == 某数 == j ^ j+1 ^ ... ^ k, 也就是 a 和 b 如果取某个数,就能满足上式.

因为前提是只有知道 [i,k] 的前缀和, 每次都利用 form i to k 这样求前缀和,必然会导致算法复杂度增加, 就可以利用上面所说的前缀和.首先求整个数组的前缀和,然后就可以在O(1)的算法复杂度的情况下,获得在[0,N]的范围内的任意[i,k]的前缀和.

最终,可以通过for i to N 和 for k = i+1 to N 就可以寻找在[0, N]范围内[i,k]的组合.

#### 思路总结
1). 从题目中得出, a == b 必然能够 a ^ b == 0, 所以,我们必须要寻找的是 xor_sum(i,k) == 0 的特征异或和.
2). 因为以上的特征要求我们知道[i,k]前缀和, 普通的求前缀和会使算法复杂度增加, 所以我们预处理[0, N] 的前缀和, 为了能够在O(1)的情况下得到[i,k]的前缀和.
3). 通过两个for循环,寻找所有在[0, N]范围内[i,k]的组合.

### 解题过程参考
异或的性质:
https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solution/xing-cheng-liang-ge-yi-huo-xiang-deng-sh-jud0/


## 代码实现:

### 思想一: 异或性质 + 前缀和
```
class Solution {
public:
  int countTriplets(vector<int>& arr) {
    int n_num = arr.size();
    int xor_sums[n_num+1];
    memset(xor_sums, 0, sizeof(xor_sums));
    int res = 0;
    // 预处理前缀和部分
    for (int i = 0; i < n_num; ++i) {
      xor_sums[i+1] = xor_sums[i] ^ arr[i];
    }

    // 枚举[i,k] 组合部分
    for (int i = 1; i < n_num; ++i) {
      for (int j = i+1; j <= n_num; ++j) {
        const auto &f = xor_sums[j];
        const auto &s = xor_sums[i-1];
        // 判断区间 xor_sum(i,j) 是否为 0 
        if ( !(f ^ s)) {
          res += (j-i);
        }
      }
    }
    return res;
  }
};
```
leetcode 测试:
0 ms 完成
7.1 MB 内存消耗

## 优缺点:

### 思想一: 异或性质 + 前缀和
思想一采用异或性质 + 前缀和的做法来解决问题.
首先,需要 O(N) 的进行前缀和预处理.
然后需要使用 O(N*N) 的来进行枚举在[0, N]范围内[i,k]的组合.
所以时间复杂度是 O(N*N)
然后, 由于需要有 N 个存储空间来进行保存相关的变量
所以空间复杂度是 O(N)
